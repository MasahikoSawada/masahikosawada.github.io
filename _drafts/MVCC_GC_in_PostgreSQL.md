---
layout: post
title: PostgreSQLのMVCCとガベージコレクション（Vacuum）
tags:
  - PostgreSQL
  - MVCC
  - Vacuum
---

このエントリは[Advent Calender 2021](https://qiita.com/advent-calendar/2021/postgresql)の22日目の記事です。

[shallow1729](https://twitter.com/shallow1729)さんの[MVCCとInnoDBでの実装について](https://shallow1729.hatenablog.com/entry/2021/05/17/212613)という記事を読んで、これのPostgreSQL版を書きたいなと思い書いてみました。

PostgreSQLにおけるトランザクションやVacuumの実装などの理解に役に立つと幸いです。また、shallow1729さんの記事も読んでいただき、MySQL（innoDB）との実装の違いなどを感じるのも面白いかもしれません。

# 同時実行制御とトランザクションID

PostgreSQLは複数のクライアントがトランザクションを同時に実行することが可能で、各トランザクションは他のトランザクションの影響を受けずに処理します。これはトランザクションのACID特性の隔離性（Isolation）の特性です。

以下に簡単な例を挙げます。

```sql
-- トランザクションA 開始
BEGIN;
SELECT * FROM test;
 val
-----
   1
(1 row)

UPDATE test SET val = val + 1;
                                     -- トランザクションB 開始
                                     BEGIN;
                                     SELECT * FROM test;
                                      val
                                     -----
                                        1
                                     (1 row)
-- トランザクションA コミット
COMMIT;

                                     SELECT * FROM test;
                                      val
                                     -----
                                        2
                                     (1 row)

                                     COMMIT;
```

トランザクションBは、トランザクションAがCOMMITする前にtestテーブルを見ると「1」が見えますが、トランザクションAがCOMMITした後にもう一度見ると更新した後の値「2」を見ます。

これは、PostgreSQLのデフォルトのトランザクション分離レベルである**READ COMMITTED**での動作で、トランザクションは、他のトランザクションがコミットした変更を見ることになります。

PostgreSQLでは、このような同時実行制御をトランザクションIDを利用して実装しています。

トランザクションID（以下、XID）は、各トランザクションに付与される単調増加する非負整数値です。PostgreSQLのテーブルの各タプルのヘッダには、`xmin`、`xmax`と呼ばれる2つのXIDが格納されています。`xmin`には、そのタプルを追加した（INSERTまたはUPDATEでの更新後のタプル）トランザクションのXIDが格納され、`xmax`には、そのタプルを削除した（DELETEまたはUPDATEでの更新前のタプル）トランザクションのXIDが格納されます。`xmin`、`xmax`は明示的に指定すればSELECTでも見ることが可能です。

例えば、XID=100のトランザクションがタプルをINSERTし、そのタプルをXID=200のトランザクションがUPDATEした場合、xmax, xminは以下のようになります。

```sql
SELECT xmin, xmax, * FROM test;
  xmin  | xmax | val
--------+------+-----
   100  |  200 |   2
(1 row)
```

PostgreSQLではUPDATE時にタプルを書き換えるのではなく、古いタプルに自分のxmaxの値を入れて、自分のXIDのをxminに入れた新しいタプルを挿入します。そして、データを読む際は`xmin`や`xmax`の値を見ながら適切なデータのみを読みます。例えば、XID=90のトランザクションから見ると、このタプルは「未来のトランザクション」によってINSERTされたものなので見えません。

複数のトランザクションが同時に同じデータを読み書きする可能性があるので、データを読む時、書くときにはロックが必要です。しかし、このように、1つのデータに対して複数のバージョンを持ち、読む側が適切なバージョンを選択することで、読み込みロックと書き込みロックが競合しないという特徴があります。このような手法をMultiversion Concurrency Control（MVCC）と呼びます。

MVCCはデータベースによって実装方法が異なります。例えば、MySQLのinnoDBでは、UNDOログ領域と呼ばれる別の領域に古いタプルを退避させて、テーブル上のタプルを新しいタプルで書き換えます。変更されたタプルは新→旧の順番でリンクされているので、古いデータを見たい時はUNDOログ領域を見に行きます。

一方PostgreSQLでは、前述の通り、古いタプルも新しいタプルも同じテーブルの領域に格納します。テーブルの中には古いタプルも新しいタプルも混ざって格納されてあり、テーブルを参照する時はその中から適切なタプル（そのトランザクションが見えるべきタプル）だけを見るようにします。

## コミットログ

ここまではトランザクションがコミットされるケースのみを扱ってきましたが、トランザクションはコミットもしくはロールバック（アボート）する可能性あります。各トランザクションの結果がどうなったかを記録している必要があります。PostgreSQLはコミットログ（トランザクションログではありません）と呼ばれるログを持っており、各トランザクション毎に2 bitsでトランザクションの状態（実行中、コミット済、ロールバック済など）を記録します。

PostgreSQLでは、INSERTしたけどその後ロールバックした、という状況でもINSERTしたタプルはテーブル内に残ります。そのようなタプルは誰からも見えてはいけません。トランザクションはコミットログを使うことで「このタプルをINSERTしたトランザクションはロールバックした（なので見てはいけない））」という事がわかります。

## スナップショット

各トランザクションはテーブルのデータを見る際に、スナップショットと呼ばれるオブジェクトを取得し、スナップショットを使ってデータを見ます。PostgreSQLにおいてスナップショットは、「古いデータ新しいデータが混ざったテーブルから、ある時点（時刻と考えても良い）において見えるデータだけを見るためのフィルター」のようなもので、同じスナップショットを使っていれば常に同じ値を読むことができます。

スナップショットの中には以下のようなデータが入っています（タプルヘッダにある`xmin`や`xmax`とは意味が異なるので注意）。

- xmin: 現在実行中で最も小さいXID。
- xmax: 完了した最も大きいXID。
- xip: 現在実行中のXIDのリスト。リスト内のXIDは必ず`xmin` <= xip[i] < `xmax`になる。

このスナップショットのデータを使い、タプルに格納されている`xmin`と`xmax`のデータ（＋コミットログ）を見ることで、そのタプルを見る・見ないの判断（可視性判断）します。

可視性判断のロジックはそこまで複雑ではありません。「タプルを追加したトランザクション」と「タプルを削除したトランザクション」の2つが、過去なのか未来なのか、さらにそれらはコミットされたのかアボートされたのか、を確認しながら見ていきます。例えば、あるタプルを追加したトランザクションが「過去のトランザクション」かつコミットされていれば、そのタプルを削除したトランザクションが「未来のトランザクション」だったり、（過去だったとしても）アボートされていれば、可視です。

もう少し具体的に見ていきます。以下のようなデータがテーブル上に有った場合、スナップショットによって見えるデータは異なります。

```
  xmin  | xmax | val
--------+------+-----
   100  |  200 |   1
   200  |      |   2
```

1. スナップショットが「xmin=90, xmax=180, xip=90, 200」
   * タプルのxmin=100はスナップショットのxmin=90より未来
   * よって**val = 1**は見えない（val = 2も同様の理由で見えない）
2. スナップショットが「xmin=150, xmax=180, xip=150, 200」
   * タプルのxmin=100はスナップショットのxmin=150より過去
   * タプルのxmax=200はスナップショットのxmax=180より未来
   * よって**val = 1**が見える
3. スナップショットが「xmin=150, xmax=250, xip=150, 200」
   * タプルのxmin=100はスナップショットのxmin=150より過去
   * タプルのxmax=200はxipの中に入っている（つまり現在実行中）
   * よって**val = 1**が見える
4. スナップショットが「xmin=150, xmax=250, xip=150」
   * タプルのxmin=100はスナップショットのxmin=150より過去
   * タプルのxmax=200はスナップショットのxmax=250より過去
   * よって**val = 1**は見えない
   * val = 2は
```

# ガベージコレクション（VACUUM）

これまで解説してきたとおり、PostgreSQLではUPDATEやDELETE時には、自分のXIDを古いタプルの`xmax`に記載することで実装されています。`xmax`にXIDを入れるだけでは、テーブルは大きくなり続けてしまうので、誰からも参照されない（誰からも可視にならない）タプルは物理的に削除し、その領域を再利用できるようにするべきです。PostgreSQLでは、Vacuumと呼ばれる機能がこの役割を担います。

Vacuumは誰からも可視にならないことが保証できる場合にのみ、そのタプルの物理削除を行います。なので、たとえそのトランザクションが参照しないことがわかっているテーブルのタプルでも、PostgreSQLはそれがわからないため物理削除をすることはできません。「誰からも可視にならないタプル」というのは「その時点で存在するどのスナップショットを使っても見えないタプル」ということなので、トランザクションが持つ各スナップショットが重要になってきます。

PostgreSQLでは、各スナップショットのxminの値と各トランザクションのXIDを共有メモリ上に持っており、それらの最小値のXID（**Oldest Xmin**）よりも小さいXIDによって削除されたデータのみVacuumできます。

スナップショットとXIDはそれぞれ存在期間が異なります。スナップショットはある時点でのデータベースデータを見るために使われるので、トランザクション分離レベルによってはSQL毎に生成されたり（例えばREAD COMMITTEDの場合）、トランザクション全体で同じスナップショットを使ったり（例えばREPEATABLE READの場合）します。一方、XIDはトランザクション内で初めてデータを更新（UPDATE、DELETEやCREATE TABLEも含む）に発行され、トランザクションが完了するまでXIDを持ち続けます。

![](/images/2021-12-22/xid_and_xmin.png))

Vacuumにおいては、Oldest Xminの値が、どれくらいのタプルを物理削除できるかに影響するのでOldest Xminを進めることがとても重要です。

例えば、長時間実行中のSQLは同じスナップショットを持ち続けているので、Oldest Xminが進まない原因となります。また、XIDが発行された後、COMMITを忘れて途中で止まっているトランザクションも、XIDをずっと保持し続けていることになるので、Oldest Xminが進まない原因となります。

「ロングトランザクションがVacuumのゴミ回収を阻害する」とよく言われるのはこの仕組のためです。

## ロングトランザクション”扱い”となるもの

Oldest Xminを算出するときにはスナップショットのxminやXIDを含め、以下のものが考慮されます（カッコ内はその値が見れるビューと列名）。

* トランザクションのXID（pg_stat_activity.backend_xid）
* スナップショットのxmin（pg_stat_activity.backend_xmin）
* 完了していない2相コミット用のトランザクション（pg_prepared_xacts.transaction）
* ロジカル・デコーディング/レプリケーション（pg_replication_slots.xminとcatalog_xmin）
* ホットスタンバイを有効にしているスタンバイサーバ（pg_stat_replication.backend_xmin）

細かい最適化はありますが、基本的にはこれらのXIDの最小値がOldest Xminとなります。

## テーブルのVacuum

Vacuumの良いところは、INSERT、DELETEやUPDATEと同時に実行可能なところです。Oldest Xminを算出した後、テーブルの先頭からスキャンし、ゴミタプルを見つけていきます。ゴミタプルとして回収した領域は空き領域マップ（Free Space Map）と呼ばれる場所に格納し、後で、INSERT等でタプルを追加するときに利用します。

自動Vacuumにより、テーブル毎の統計情報（ゴミタプルの数など）をもとに自動にVacuumされます。手動でVacuumを実行することもでき、手動の場合はパラレルVacuumやVacuum Fullが利用可能です。

## インデックスのVacuum

ここまではテーブルについての話でしたが、テーブルを更新した場合、テーブルだけでなくインデックスにもゴミが溜まるので、インデックスでのVacuumが必要です。PostgreSQLはすべてのインデックスがテーブルを直接参照し、InnoDBのようなセカンダリインデックスの仕組みはありません。

PostgreSQLでは、テーブルにタプルを挿入する際はテーブル、インデックスの両方に挿入しますが、削除する際はテーブルのタプルだけ削除します。なので、削除したタプルを参照するインデックスはまだこのる事になります。次にインデックスを経由してテーブルを取得した時に、「このインデックスが参照しているタプルは削除済み」ということがわかるのでインデックスのタプルに削除マークを入れます(インデックスタプルにはxmaxを入れるところはなく、ここでは本当に削除を示すフラグを立てるだけ)。インデックスVacuum時には、削除マークのついたインデックスを回収します。

## 最後に

PostgreSQLでのMVCCの実装やガベージコレクション（Vacuum）の仕組みが伝われば幸いです。トランザクション周りの他の機能（SAVEPOINTや2相コミット）、Vacuumでのいろいろな最適化などは別の機会に記事にできればと考えています。最後まで読んでいただきありがとうございました。
